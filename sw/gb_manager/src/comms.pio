; SM83/8080 bus communication for the Nintendo Game Boy.
; Copyright (c) 2021 Mahyar Koshkouei
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted, provided that the above copyright notice and
; this permission notice appear in all copies.
; THIS SOFTWARE IS PROVIDED 'AS-IS', WITHOUT ANY EXPRESS OR IMPLIED WARRANTY.
; IN NO EVENT WILL THE AUTHORS BE HELD LIABLE FOR ANY DAMAGES ARISING FROM
; THE USE OF THIS SOFTWARE.
;

.define PHI		13
.define NWR		14
.define NRD		15
.define NCS		16
.define ADDR1_OE	17
.define ADDR2_OE	18
.define DATA_OE		19
.define DATA_DIR	20
.define M0		21
.define M7		28

;; Read address from GB bus for ROM reads and writes
.program gb_bus_get_address

; Side-set pins are PIO_ADDR1_OE, PIO_ADDR2_OE, PIO_DATA_OE, and PIO_DATA_DIR.
.side_set 4 opt

gb_bus_get_address_start:
;	Wait for a ROM read/write instruction.
	wait 0 GPIO M7 side 0b1010 ; Side: Set multiplexor to HIGH Address byte

;	Read LOW byte of address into ISR.
	in PINS, 8 side 0b0110
;	Read HIGH byte of address into ISR.
	in PINS, 8 side 0b1010

;	Jump if a data read is requested.
	jmp PIN gb_bus_write_data side 0b1100; Side: Set multiplexor to Data
					; byte

;	No data is to be read, so push address to LSB and zero data byte.
	in NULL, 16

;	Autopush: Push address from ISR to RX FIFO
;	push noblock

;	Wait for low edge of PHI, before checking for next instruction.
	wait 0 GPIO PHI

gb_bus_next_instr:
;	Wait for next instruction
	wait 1 GPIO PHI
.wrap

gb_bus_write_data:
;	Fill the X register with ones.
	mov X, ~null

;	Wait for data to become ready. */
	wait 0 GPIO NWR

;	Read Data byte.
	in PINS, 8 side 0b1100 ; Data

;	Shift the address and data to LSB, and fill the MSB byte with ones.
	in X, 8

;	Autopush: Push address, data, and write flag from ISR to RX FIFO
;	push noblock

	jmp gb_bus_next_instr
; End

;; Read address from GB bus for RAM reads and writes
;; Only addresses between A000 and BFFF inclusive must be handled by the CPU.
.program gb_bus_get_cs

; Side-set pins are PIO_ADDR1_OE, PIO_ADDR2_OE, PIO_DATA_OE, and PIO_DATA_DIR.
.side_set 4 opt

gb_bus_get_cs_start:
;	Wait for a RAM read/write instruction.
	wait 0 GPIO NCS

;	Read LOW byte of address into ISR.
	in PINS, 8 side 0b0110
;	Read HIGH byte of address into ISR.
	in PINS, 8 side 0b1010

;	Jump if a data read is requested.
	jmp PIN gb_bus_write_data side 0b1100; Side: Set multiplexor to Data
					; byte

;	No data is to be read, so push address to LSB and zero data byte.
	in NULL, 16

;	Autopush: Push address from ISR to RX FIFO
;	push noblock

;	Wait for low edge of PHI, before checking for next instruction.
	wait 0 GPIO PHI

gb_bus_next_instr:
;	Wait for next instruction
	wait 1 GPIO PHI
.wrap

gb_bus_write_data:
;	Fill the X register with ones.
	mov X, ~null

;	Wait for data to become ready.
	wait 0 GPIO NWR

;	Read Data byte.
	in PINS, 8 side 0b1100 ; Data

;	Shift the address and data to LSB, and fill the MSB byte with ones.
	in X, 8

;	Autopush: Push address, data, and write flag from ISR to RX FIFO
;	push noblock

	jmp gb_bus_next_instr
; End

;; Send data to the Game Boy. This is done when the Game Boy is performing a
;; read operation of an address.
.program gb_bus_write_data

; Side-set pins are PIO_ADDR1_OE, PIO_ADDR2_OE, PIO_DATA_OE, and PIO_DATA_DIR.
.side_set 4 opt

public gb_bus_write_data:
;	Pull data from TX FIFO to OSR
;	This is not required if autopull is enabled
;	Side: Return control of the data bus to the Game Boy.
	pull ifempty block

;	Output data from OSR to data pins
	out PINS, 8

;	Set Data pins to OUTPUT.
;	See: https://www.raspberrypi.org/forums/viewtopic.php?t=303335
	mov osr, ~null side 0b1100 ; Set OSR to all ones
				; Side: set multiplexor to Data byte.
	out pindirs, 8 side 0b1101 ; Output ones to data pindirs
				; Side: change data direction to RP2040 -> GB.

;	Keep data output active until new clock cycle.
;	Side: Stay in control of the data bus.
	wait 0 GPIO PHI
	wait 1 GPIO PHI

;	Set Data pins to INPUT.
;	See: https://www.raspberrypi.org/forums/viewtopic.php?t=303335
	mov osr, null side 0b1010  ; Set OSR to all zeros
				; Side: set multiplexor to HIGH Address byte.
				; Side: set DATA_DIR to GB -> RP2040 (A -> B)
	out pindirs, 8		; Output ones to data pindirs


;	Wait for next data output
.wrap

% c-sdk {
void gb_bus_program_init(PIO pio, unsigned sm_a15, unsigned sm_ncs,
		unsigned sm_do)
{
	pio_sm_config sm_config_a15, sm_config_ncs, sm_config_do;
	uint gb_bus_get_address_off, gb_bus_get_cs_off, gb_bus_write_data_off;

	gb_bus_get_address_off = pio_add_program(pio, &gb_bus_get_address_program);
	gb_bus_get_cs_off = pio_add_program(pio, &gb_bus_get_cs_program);
	gb_bus_write_data_off = pio_add_program(pio, &gb_bus_write_data_program);

	sm_config_a15 = gb_bus_get_address_program_get_default_config(gb_bus_get_address_off);
	sm_config_ncs = gb_bus_get_address_program_get_default_config(gb_bus_get_cs_off);
	sm_config_do = gb_bus_write_data_program_get_default_config(gb_bus_write_data_off);

	/* Configure SM_A15, and SM_CS. */
	/* Setting the "IN" pins on "gb_bus_get_address" state machines. */
	/* Set the first "IN" pin on the state machines to the first address pin. */
	sm_config_set_in_pins(&sm_config_a15, PIO_M0);
	sm_config_set_in_pins(&sm_config_ncs, PIO_M0);
	/* Configure "OUT" pins to the data bus. */
	sm_config_set_out_pins(&sm_config_do, PIO_M0, NUM_MULTIPLEX_PINS);

	/* Configure "JMP" pins. */
	/* If RD is HIGH, then this JMP instruction will allow the state machine to
	 * additionally read the data from the Game Boy. */
	sm_config_set_jmp_pin(&sm_config_a15, PIO_NRD);
	sm_config_set_jmp_pin(&sm_config_ncs, PIO_NRD);

	/* Set number of bits in RX FIFO. */
	/* TODO: This may only be required for autopush functionality. */
	sm_config_set_in_shift(&sm_config_a15, true, true, 32);
	sm_config_set_in_shift(&sm_config_ncs, true, true, 32);
	/* Set number of bits in TX FIFO. */
	sm_config_set_out_shift(&sm_config_do, true, false, NUM_MULTIPLEX_PINS);

	/* Set clock speed of PIO state machines. */
	sm_config_set_clkdiv_int_frac(&sm_config_a15, 1, 0);
	sm_config_set_clkdiv_int_frac(&sm_config_ncs, 1, 0);
	sm_config_set_clkdiv_int_frac(&sm_config_do,  1, 0);

	/* Set initial pin directions. */
	pio_sm_set_consecutive_pindirs(pio, sm_a15, PIO_PHI, 4, false);
	pio_sm_set_consecutive_pindirs(pio, sm_a15, PIO_ADDR1_OE, 4, true);
	pio_sm_set_consecutive_pindirs(pio, sm_a15, PIO_M0, 8, false);

	/* Allow PIO to set OE and MX GPIO pins as output. */
	for(unsigned pin = PIO_ADDR1_OE; pin <= PIO_M7; pin++)
		pio_gpio_init(pio, pin);

	/* Set "sideset" configuration to allow OE and DATA_DIR to be changed
	 on each instruction for the state machines. */
        sm_config_set_sideset(&sm_config_a15, 4, true, false);
        sm_config_set_sideset(&sm_config_ncs, 4, false, false);
	sm_config_set_sideset(&sm_config_do, 4, true, false);
	sm_config_set_sideset_pins(&sm_config_a15, PIO_ADDR1_OE);
	sm_config_set_sideset_pins(&sm_config_ncs, PIO_ADDR1_OE);
	sm_config_set_sideset_pins(&sm_config_do, PIO_ADDR1_OE);

	/* Initialise all state machines. */
	pio_sm_init(pio, sm_a15, gb_bus_get_address_off,  &sm_config_a15);
	pio_sm_init(pio, sm_ncs, gb_bus_get_cs_off,  &sm_config_ncs);
	pio_sm_init(pio, sm_do,  gb_bus_write_data_off, &sm_config_do);
}
%}
